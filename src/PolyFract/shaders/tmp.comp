

//computing roots (without color and error detection) the old way
void find_roots(in float poly_r[32], 
                in float poly_i[32],
                in int poly_len,
                inout CompactComplexFloatWithColor _z[32])
{
    float _monic_r[32];
    float _monic_i[32];
    float _newZ_r[32];
    float _newZ_i[32];

    if (poly_len < 2)
        return;

    uint n = poly_len - 1;
    float a0_r = poly_r[0];
    float a0_i = poly_i[0];
    if (a0_r == 0 && a0_i == 0)
        return;

    float a0_mag2 = a0_r * a0_r + a0_i * a0_i;
    float inv_a0_mag2 = 1.0 / a0_mag2;

    _monic_r[0] = 1;
    _monic_i[0] = 0;
    for (int i = 1; i <= n; ++i) {
        float pr = poly_r[i];
        float pi = poly_i[i];
        float num_r = pr * a0_r + pi * a0_i;
        float num_i = pi * a0_r - pr * a0_i;
        _monic_r[i] = num_r * inv_a0_mag2;
        _monic_i[i] = num_i * inv_a0_mag2;
    }

    float maxAbs = 0.0;
    for (int i = 1; i <= n; i++)
    {
        float m2 = mag2(_monic_r[i], _monic_i[i]);
        if (m2 > maxAbs * maxAbs) 
            maxAbs = sqrt(m2);
    }
    float r = 1.0 + maxAbs;

    float twoPiOverN = 2.0 * M_PI / n;
    for (int k = 0; k < n; k++)
    {
        float angle = twoPiOverN * k;
        _z[k].position.x = r * cos(angle);
        _z[k].position.y = r * sin(angle);
    }

    for (int iter = 0; iter < MaxIterations; iter++)
    {
        double maxDelta2 = 0.0;     //in this implementation this must be double
        for (int i = 0; i < n; i++)
        {
            float zi_r = _z[i].position.x;
            float zi_i = _z[i].position.y;

            float p_r = _monic_r[0];
            float p_i = _monic_i[0];
            for (int k = 1; k <= n; k++)
            {
                float p_r_tmp = p_r * zi_r - p_i * zi_i + _monic_r[k];
                float p_i_tmp = p_r * zi_i + p_i * zi_r + _monic_i[k];
                p_r = p_r_tmp;
                p_i = p_i_tmp;
            }

            float denom_r = 1;
            float denom_i = 0;
            for (int j = 0; j < n; j++)
            {
                if (j == i)
                    continue;
                float mult_r = zi_r - _z[j].position.x;
                float mult_i = zi_i - _z[j].position.y;
                float denom_r_tmp = denom_r * mult_r - denom_i * mult_i;
                float denom_i_tmp = denom_r * mult_i + denom_i * mult_r;
                denom_r = denom_r_tmp;
                denom_i = denom_i_tmp;
            }

            float div = denom_r * denom_r + denom_i * denom_i;
            float delta_r = (p_r * denom_r + p_i * denom_i) / div;
            float delta_i = (p_i * denom_r - p_r * denom_i) / div;

            float ziNew_r = zi_r - delta_r;
            float ziNew_i = zi_i - delta_i;

            _newZ_r[i] = ziNew_r;
            _newZ_i[i] = ziNew_i;

            float d2 = mag2(delta_r, delta_i);
            if (d2 > maxDelta2) maxDelta2 = d2;
        }

        for (int i = 0; i < n; i++)
        {
            _z[i].position.x = _newZ_r[i];
            _z[i].position.y = _newZ_i[i];
        }

        if (maxDelta2 < (Tolerance * Tolerance)) break;
    }
}





// adding color and removing errors from computed roots
void post_process(in float poly_r[32], 
                  in float poly_i[32],
                  in int poly_len,
                  inout CompactComplexFloatWithColor _z[32])
{
    // compute colors from deriviative value at given root
    uint n = poly_len - 1;
    for (int i = 0; i < n; i++)
    {
        float a = angle_at(poly_r, poly_i, poly_len, _z[i].position.x, _z[i].position.y);
        float h = (a + M_PI) / (2 * M_PI);
        _z[i].color.rgb = hue_to_rgb(h);
    }

    // remove errors by checking if p(root) is (more or less) zero
    for (int i = 0; i < n; i++)
    {
        float r_r = _z[i].position.x;
        float r_i = _z[i].position.y;

        float v_r = poly_r[0];
        float v_i = poly_i[0];
        for (int j = 1; j <= n; j++)
        {
            float v_r_tmp = v_r * r_r - v_i * r_i + poly_r[j];
            float v_i_tmp = v_r * r_i + v_i * r_r + poly_i[j];
            v_r = v_r_tmp;
            v_i = v_i_tmp;
        }

        float v_m = mag(v_i, v_r);
        if (v_m > ErrorMargin)
        {
            _z[i].position.x = ErrorMarker;
            _z[i].position.y = ErrorMarker;
            _z[i].color.r = 0;
            _z[i].color.g = 0;
            _z[i].color.b = 0;
        }
    }
}