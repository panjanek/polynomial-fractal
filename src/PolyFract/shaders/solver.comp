#version 430

layout(local_size_x = 16) in;

struct ComputeShaderConfig {
    int order;
    int coeffValuesCount;
    int polysCount;
    float coeffsValues_r[16];
    float coeffsValues_i[16];
};

struct CompactComplexFloatWithColor {
    vec2 position;
    vec4 color;
};

// input buffer - only configuration
layout(std430, binding = 0) buffer ConfigBuffer {
    ComputeShaderConfig config;
};

// Output buffer containing point positions + colors
layout(std430, binding = 1) buffer OutputBuffer {
    CompactComplexFloatWithColor points[];
};

const float M_PI        = 3.14159265358979323846;
const int MaxIterations = 32;
const float Tolerance   = 1e-08;
const float ErrorMargin = 0.001;
const int ErrorMarker   = 1000;


float mag2(float xr, float xi) 
{
    return xr * xr + xi * xi;
}

float mag(float xr, float xi)
{
    return sqrt(mag2(xr, xi));
}

float fast_atan2(float y, float x)
{
    float ax = abs(x);
    float ay = abs(y);

    float m = min(ax, ay) / max(ax, ay);
    float s = m * m;

    float a = (((-0.04649647 * s + 0.15931422) * s - 0.32762277) * s * m + m);

    a = (ay > ax) ? (1.57079637 - a) : a;
    a = (x < 0.0) ? (3.14159274 - a) : a;

    return a * sign(y);
}

float angle_at(
    in float poly_r[32],
    in float poly_i[32],
    in int   poly_len,
    in float x_r,
    in float x_i)
{
    int n = poly_len - 1;
    vec2 d = vec2(0.0);
    vec2 x = vec2(x_r, x_i);
    float k = float(n);
    for (int i = 0; i < n; ++i)
    {
        vec2 a = vec2(poly_r[i], poly_i[i]) * k;
        // d = d * x + a
        d = vec2(d.x * x.x - d.y * x.y, d.x * x.y + d.y * x.x) + a;
        k -= 1.0;
    }

    return fast_atan2(d.y, d.x);
}

vec3 hue_to_rgb(float h)
{
    // 6-sector hue wheel
    vec3 k = vec3(0.0, 4.0, 2.0);
    vec3 p = abs(fract(h + k / 6.0) * 6.0 - 3.0);
    return clamp(p - 1.0, 0.0, 1.0);
}

void find_roots(in float poly_r[32], 
                in float poly_i[32],
                in int poly_len,
                inout CompactComplexFloatWithColor _z[32])
{
    float _monic_r[32];
    float _monic_i[32];
    float _newZ_r[32];
    float _newZ_i[32];

    if (poly_len < 2)
        return;

    uint n = poly_len - 1;
    float a0_r = poly_r[0];
    float a0_i = poly_i[0];
    if (a0_r == 0 && a0_i == 0)
        return;

    float a0_mag2 = a0_r * a0_r + a0_i * a0_i;
    float inv_a0_mag2 = 1.0 / a0_mag2;

    _monic_r[0] = 1;
    _monic_i[0] = 0;
    for (int i = 1; i <= n; ++i) {
        float pr = poly_r[i];
        float pi = poly_i[i];
        float num_r = pr * a0_r + pi * a0_i;
        float num_i = pi * a0_r - pr * a0_i;
        _monic_r[i] = num_r * inv_a0_mag2;
        _monic_i[i] = num_i * inv_a0_mag2;
    }

    float maxAbs = 0.0;
    for (int i = 1; i <= n; i++)
    {
        float m2 = mag2(_monic_r[i], _monic_i[i]);
        if (m2 > maxAbs * maxAbs) 
            maxAbs = sqrt(m2);
    }
    float r = 1.0 + maxAbs;

    float twoPiOverN = 2.0 * M_PI / n;
    for (int k = 0; k < n; k++)
    {
        float angle = twoPiOverN * k;
        _z[k].position.x = r * cos(angle);
        _z[k].position.y = r * sin(angle);
    }

    for (int iter = 0; iter < MaxIterations; iter++)
    {
        double maxDelta2 = 0.0;
        for (int i = 0; i < n; i++)
        {
            float zi_r = _z[i].position.x;
            float zi_i = _z[i].position.y;

            float p_r = _monic_r[0];
            float p_i = _monic_i[0];
            for (int k = 1; k <= n; k++)
            {
                float p_r_tmp = p_r * zi_r - p_i * zi_i + _monic_r[k];
                float p_i_tmp = p_r * zi_i + p_i * zi_r + _monic_i[k];
                p_r = p_r_tmp;
                p_i = p_i_tmp;
            }

            float denom_r = 1;
            float denom_i = 0;
            for (int j = 0; j < n; j++)
            {
                if (j == i)
                    continue;
                float mult_r = zi_r - _z[j].position.x;
                float mult_i = zi_i - _z[j].position.y;
                float denom_r_tmp = denom_r * mult_r - denom_i * mult_i;
                float denom_i_tmp = denom_r * mult_i + denom_i * mult_r;
                denom_r = denom_r_tmp;
                denom_i = denom_i_tmp;
            }

            float div = denom_r * denom_r + denom_i * denom_i;
            float delta_r = (p_r * denom_r + p_i * denom_i) / div;
            float delta_i = (p_i * denom_r - p_r * denom_i) / div;

            float ziNew_r = zi_r - delta_r;
            float ziNew_i = zi_i - delta_i;

            _newZ_r[i] = ziNew_r;
            _newZ_i[i] = ziNew_i;

            float d2 = mag2(delta_r, delta_i);
            if (d2 > maxDelta2) maxDelta2 = d2;
        }

        for (int i = 0; i < n; i++)
        {
            _z[i].position.x = _newZ_r[i];
            _z[i].position.y = _newZ_i[i];
        }

        if (maxDelta2 < (Tolerance * Tolerance)) break;
    }
}


void post_process(in float poly_r[32], 
                  in float poly_i[32],
                  in int poly_len,
                  inout CompactComplexFloatWithColor _z[32])
{
    // compute colors from deriviative value at given root
    uint n = poly_len - 1;
    for (int i = 0; i < n; i++)
    {
        float a = angle_at(poly_r, poly_i, poly_len, _z[i].position.x, _z[i].position.y);
        float h = (a + M_PI) / (2 * M_PI);
        _z[i].color.rgb = hue_to_rgb(h);
    }

    // remove errors by checking if p(root) is (more or less) zero
    for (int i = 0; i < n; i++)
    {
        float r_r = _z[i].position.x;
        float r_i = _z[i].position.y;

        float v_r = poly_r[0];
        float v_i = poly_i[0];
        for (int j = 1; j <= n; j++)
        {
            float v_r_tmp = v_r * r_r - v_i * r_i + poly_r[j];
            float v_i_tmp = v_r * r_i + v_i * r_r + poly_i[j];
            v_r = v_r_tmp;
            v_i = v_i_tmp;
        }

        float v_m = mag(v_i, v_r);
        if (v_m > ErrorMargin)
        {
            _z[i].position.x = ErrorMarker;
            _z[i].position.y = ErrorMarker;
            _z[i].color.r = 0;
            _z[i].color.g = 0;
            _z[i].color.b = 0;
        }
    }
}


void main()
{
    uint idx = gl_GlobalInvocationID.x;

    float poly_r[32];
    float poly_i[32];
    CompactComplexFloatWithColor _z[32];
    uint poly_len = config.order + 1; 

    uint rootsCount = config.polysCount * config.order; 
    if (idx >=0 && idx < config.polysCount) {

        // create poly from number
        uint polyIdx = idx;
        for (int j = 0; j < poly_len; j++)
        {
            uint coeffIdx = polyIdx % config.coeffValuesCount;
            polyIdx = polyIdx / config.coeffValuesCount;
            poly_r[j] = config.coeffsValues_r[coeffIdx];
            poly_i[j] = config.coeffsValues_i[coeffIdx];
        }

        find_roots(poly_r, poly_i, config.order+1, _z);
        post_process(poly_r, poly_i, config.order+1, _z);

        polyIdx = idx;
        for(int i=0; i<config.order; i++)
        {
            uint pointIdx = polyIdx * config.order + i; 
            points[pointIdx] = _z[i];
        }

    } else if (idx < config.polysCount + config.coeffValuesCount) {
        uint coeffIdx = idx - config.polysCount;
        points[rootsCount + coeffIdx].position.x = config.coeffsValues_r[coeffIdx];
        points[rootsCount + coeffIdx].position.y = config.coeffsValues_i[coeffIdx];
        points[rootsCount + coeffIdx].color.r = 255.0;
        points[rootsCount + coeffIdx].color.g = 255.0;
        points[rootsCount + coeffIdx].color.b = 255.0;  
    }
}