#version 430

#pragma optimize(on)


layout(local_size_x = 16) in;

struct ComputeShaderConfig {
    int order;
    int coeffValuesCount;
    int polysCount;
    float coeffsValues_r[16];
    float coeffsValues_i[16];
};

struct CompactComplexFloatWithColor {
    vec2 position;
    vec4 color;
};

// input buffer - only configuration
layout(std430, binding = 0) buffer ConfigBuffer {
    ComputeShaderConfig config;
};

// Output buffer containing point positions + colors
layout(std430, binding = 1) buffer OutputBuffer {
    CompactComplexFloatWithColor points[];
};

const float M_PI        = 3.14159265358979323846;
const int MaxIterations = 28;
const float Tolerance   = 1e-10;
const float ErrorMargin = 0.001;
const int ErrorMarker   = 1000;


float mag2(float xr, float xi) 
{
    return xr * xr + xi * xi;
}

float mag(float xr, float xi)
{
    return sqrt(mag2(xr, xi));
}

float fast_atan2(float y, float x)
{
    float ax = abs(x);
    float ay = abs(y);

    float m = min(ax, ay) / max(ax, ay);
    float s = m * m;

    float a = (((-0.04649647 * s + 0.15931422) * s - 0.32762277) * s * m + m);

    a = (ay > ax) ? (1.57079637 - a) : a;
    a = (x < 0.0) ? (3.14159274 - a) : a;

    return a * sign(y);
}

float angle_at(
    in float poly_r[32],
    in float poly_i[32],
    in int   poly_len,
    in float x_r,
    in float x_i)
{
    int n = poly_len - 1;
    vec2 d = vec2(0.0);
    vec2 x = vec2(x_r, x_i);
    float k = float(n);
    for (int i = 0; i < n; ++i)
    {
        vec2 a = vec2(poly_r[i], poly_i[i]) * k;
        // d = d * x + a
        d = vec2(d.x * x.x - d.y * x.y, d.x * x.y + d.y * x.x) + a;
        k -= 1.0;
    }

    return fast_atan2(d.y, d.x);
}

vec3 hue_to_rgb(float h)
{
    // 6-sector hue wheel
    vec3 k = vec3(0.0, 4.0, 2.0);
    vec3 p = abs(fract(h + k / 6.0) * 6.0 - 3.0);
    return clamp(p - 1.0, 0.0, 1.0);
}

void find_roots2(
    in float poly_r[32],
    in float poly_i[32],
    in int   poly_len,
    inout CompactComplexFloatWithColor _z[32])
{
    if (poly_len < 2)
        return;

    int n = poly_len - 1;

    vec2 a[32];

    vec2 a0 = vec2(poly_r[0], poly_i[0]);
    float a0_inv = 1.0 / dot(a0, a0);

    a[0] = vec2(1.0, 0.0);

    for (int i = 1; i <= n; ++i)
    {
        vec2 p = vec2(poly_r[i], poly_i[i]);
        a[i] = vec2(
            p.x * a0.x + p.y * a0.y,
            p.y * a0.x - p.x * a0.y
        ) * a0_inv;
    }

    float maxCoeff2 = 0.0;
    for (int i = 1; i <= n; ++i)
        maxCoeff2 = max(maxCoeff2, dot(a[i], a[i]));

    float r = 1.0 + sqrt(maxCoeff2);

    float theta = 6.28318530718 / float(n);
    float cs = cos(theta);
    float sn = sin(theta);

    mediump vec2 z[32];
    vec2 w = vec2(r, 0.0);

    for (int i = 0; i < n; ++i)
    {
        z[i] = w;
        w = vec2(
            w.x * cs - w.y * sn,
            w.x * sn + w.y * cs
        );
    }

    for (int iter = 0; iter < MaxIterations; ++iter)
    {
        float maxDelta2 = 0.0; //in this implementation this works

        for (int i = 0; i < n; ++i)
        {
            mediump vec2 zi = z[i];

            vec2 p = a[0];
            for (int k = 1; k <= n; ++k)
            {
                p = vec2(
                    p.x * zi.x - p.y * zi.y,
                    p.x * zi.y + p.y * zi.x
                ) + a[k];
            }

            vec2 denom = vec2(1.0, 0.0);

            for (int j = 0; j < n; ++j)
            {
                if (j == i) continue;

                vec2 d = zi - z[j];
                denom = vec2(
                    denom.x * d.x - denom.y * d.y,
                    denom.x * d.y + denom.y * d.x
                );
            }

            float inv = 1.0 / dot(denom, denom);

            vec2 delta = vec2(
                p.x * denom.x + p.y * denom.y,
                p.y * denom.x - p.x * denom.y
            ) * inv;

            z[i] = zi - delta;

            maxDelta2 = max(maxDelta2, dot(delta, delta));
        }

        if (maxDelta2 < (Tolerance * Tolerance))
            break;
    }

    for (int i = 0; i < n; ++i)
        _z[i].position = z[i];

    // compute colors from deriviative value at given root
    for (int i = 0; i < n; i++)
    {
        float a = angle_at(poly_r, poly_i, poly_len, _z[i].position.x, _z[i].position.y);
        float h = (a + M_PI) / (2 * M_PI);
        _z[i].color.rgb = hue_to_rgb(h);
    }

    // remove errors by checking if p(root) is (more or less) zero
    for (int i = 0; i < n; i++)
    {
        float r_r = _z[i].position.x;
        float r_i = _z[i].position.y;

        float v_r = poly_r[0];
        float v_i = poly_i[0];
        for (int j = 1; j <= n; j++)
        {
            float v_r_tmp = v_r * r_r - v_i * r_i + poly_r[j];
            float v_i_tmp = v_r * r_i + v_i * r_r + poly_i[j];
            v_r = v_r_tmp;
            v_i = v_i_tmp;
        }

        float v_m = mag(v_i, v_r);
        if (v_m > ErrorMargin)
        {
            _z[i].position.x = ErrorMarker;
            _z[i].position.y = ErrorMarker;
            _z[i].color.r = 0;
            _z[i].color.g = 0;
            _z[i].color.b = 0;
        }
    }
}


void main()
{
    uint idx = gl_GlobalInvocationID.x;

    float poly_r[32];
    float poly_i[32];
    CompactComplexFloatWithColor _z[32];
    uint poly_len = config.order + 1; 

    uint rootsCount = config.polysCount * config.order; 
    if (idx >=0 && idx < config.polysCount) {

        // create poly from number
        uint polyIdx = idx;
        for (int j = 0; j < poly_len; j++)
        {
            uint coeffIdx = polyIdx % config.coeffValuesCount;
            polyIdx = polyIdx / config.coeffValuesCount;
            poly_r[j] = config.coeffsValues_r[coeffIdx];
            poly_i[j] = config.coeffsValues_i[coeffIdx];
        }

        find_roots2(poly_r, poly_i, config.order+1, _z);
        //post_process(poly_r, poly_i, config.order+1, _z);

        polyIdx = idx;
        for(int i=0; i<config.order; i++)
        {
            uint pointIdx = polyIdx * config.order + i; 
            points[pointIdx] = _z[i];
        }

    } else if (idx < config.polysCount + config.coeffValuesCount) {
        uint coeffIdx = idx - config.polysCount;
        points[rootsCount + coeffIdx].position.x = config.coeffsValues_r[coeffIdx];
        points[rootsCount + coeffIdx].position.y = config.coeffsValues_i[coeffIdx];
        points[rootsCount + coeffIdx].color.r = 255.0;
        points[rootsCount + coeffIdx].color.g = 255.0;
        points[rootsCount + coeffIdx].color.b = 255.0;  
    }
}