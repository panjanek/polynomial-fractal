#version 430

layout(local_size_x = 256) in;

struct ComputeShaderConfig {
    int order;
    int coeffValuesCount;
    int polysCount;
    float coeffsValues_r[16];
    float coeffsValues_i[16];
};

struct CompactComplexFloatWithColor {
    float r;
    float i;
    float colorR;
    float colorG;
    float colorB;
};

// input buffer
layout(std430, binding = 0) buffer ConfigBuffer {
    ComputeShaderConfig config;
};

// Output buffer containing point positions + colors
layout(std430, binding = 1) buffer OutputBuffer {
    CompactComplexFloatWithColor points[];
};

const float M_PI        = 3.14159265358979323846;
const int MaxIterations = 48;
const float Tolerance   = 1e-10;

const float ErrorMargin = 0.01;
const int ErrorMarker   = 1000;


float mag2(float xr, float xi) 
{
    return xr * xr + xi * xi;
}

double mag2d(double xr, double xi) 
{
    return xr * xr + xi * xi;
}

float mag(float xr, float xi)
{
    return sqrt(mag2(xr, xi));
}

float fast_atan2(float y, float x)
{
    float absY = abs(y) + 1e-10f;

    float angle;
    if (x >= 0)
    {
        float r = (x - absY) / (x + absY);
        angle = (M_PI / 4) - (0.9675 * r);
    }
    else
    {
        float r = (x + absY) / (absY - x);
        angle = (3 * M_PI / 4) - (0.9675 * r);
    }

    return (y < 0) ? -angle : angle;
}

float angle_at(in float poly_r[32], 
               in float poly_i[32],
               in int poly_len, 
               in float x_r,
               in float x_i)
{
    int n = poly_len - 1;
    float d_r = 0;
    float d_i = 0;

    for (int i = 0; i < n; i++)
    {
        float d_r_tmp = d_r * x_r - d_i * x_i + poly_r[i] * (n - i);
        float d_i_tmp = d_r * x_i + d_i * x_r + poly_i[i] * (n - 1);
        d_r = d_r_tmp;
        d_i = d_i_tmp;
    }

    return fast_atan2(d_i, d_r);
}


void hsv_to_rgb(in float h, out float r, out float g, out float b)
{
    if (h < 0)
        h = 0;

    if (h > 255)
        h = 255;

    int x = int(h * 6);
    int sector = x >> 8;
    int frac = x & 255;

    int p = 0;
    int q = 255 - frac;
    int t = frac;

    switch (sector)
    {
        case 0: r = 255; g = t; b = 0; return;
        case 1: r = q; g = 255; b = 0; return;
        case 2: r = 0; g = 255; b = t; return;
        case 3: r = 0; g = q; b = 255; return;
        case 4: r = t; g = 0; b = 255; return;
        default:
        case 5: r = 255; g = 0; b = q; return;
    }
}


void evaluate_poly(in float poly_r[32], 
                   in float poly_i[32],
                   in int poly_len,
                   inout CompactComplexFloatWithColor _z[32])
{
    double _monic_r[32];
    double _monic_i[32];
    double _newZ_r[32];
    double _newZ_i[32];

    double _zd_r[32];
    double _zd_i[32];

    if (poly_len < 2)
        return;

    uint n = poly_len - 1;
    double a0_r = poly_r[0];
    double a0_i = poly_i[0];
    if (a0_r == 0 && a0_i == 0)
        return;

    double a0_mag2 = a0_r * a0_r + a0_i * a0_i;
    double inv_a0_mag2 = 1.0 / a0_mag2;

    _monic_r[0] = 1;
    _monic_i[0] = 0;
    for (int i = 1; i <= n; ++i) {
        double pr = poly_r[i];
        double pi = poly_i[i];
        double num_r = pr * a0_r + pi * a0_i;
        double num_i = pi * a0_r - pr * a0_i;
        _monic_r[i] = num_r * inv_a0_mag2;
        _monic_i[i] = num_i * inv_a0_mag2;
    }

    double maxAbs = 0.0;
    for (int i = 1; i <= n; i++)
    {
        double m2 = mag2d(_monic_r[i], _monic_i[i]);
        if (m2 > maxAbs * maxAbs) 
            maxAbs = sqrt(m2);
    }
    double r = 1.0 + maxAbs;

    float twoPiOverN = 2.0 * M_PI / n;
    for (int k = 0; k < n; k++)
    {
        float angle = twoPiOverN * k;
        _zd_r[k] = r * double(cos(angle));
        _zd_i[k] = r * double(sin(angle));
    }

    for (int iter = 0; iter < MaxIterations; iter++)
    {
        double maxDelta2 = 0.0;
        for (int i = 0; i < n; i++)
        {
            double zi_r = _zd_r[i];
            double zi_i = _zd_i[i];

            double p_r = _monic_r[0];
            double p_i = _monic_i[0];
            for (int k = 1; k <= n; k++)
            {
                double p_r_tmp = p_r * zi_r - p_i * zi_i + _monic_r[k];
                double p_i_tmp = p_r * zi_i + p_i * zi_r + _monic_i[k];
                p_r = p_r_tmp;
                p_i = p_i_tmp;
            }

            double denom_r = 1;
            double denom_i = 0;
            for (int j = 0; j < n; j++)
            {
                if (j == i)
                    continue;
                double mult_r = zi_r - _zd_r[j];
                double mult_i = zi_i - _zd_i[j];
                double denom_r_tmp = denom_r * mult_r - denom_i * mult_i;
                double denom_i_tmp = denom_r * mult_i + denom_i * mult_r;
                denom_r = denom_r_tmp;
                denom_i = denom_i_tmp;
            }

            double div = denom_r * denom_r + denom_i * denom_i;
            double delta_r = (p_r * denom_r + p_i * denom_i) / div;
            double delta_i = (p_i * denom_r - p_r * denom_i) / div;

            double ziNew_r = zi_r - delta_r;
            double ziNew_i = zi_i - delta_i;

            _newZ_r[i] = ziNew_r;
            _newZ_i[i] = ziNew_i;

            double d2 = double(mag2(float(delta_r), float(delta_i)));
            if (d2 > maxDelta2) maxDelta2 = d2;
        }

        for (int i = 0; i < n; i++)
        {
            _zd_r[i] = _newZ_r[i];
            _zd_i[i] = _newZ_i[i];
        }

        if (maxDelta2 < (Tolerance * Tolerance)) break;
    }

    for (int i = 0; i < n; i++)
    {
        _z[i].r = float(_zd_r[i]);
        _z[i].i = float(_zd_i[i]);
        float a = angle_at(poly_r, poly_i, poly_len, _z[i].r, _z[i].i);
        float h = (255 * (M_PI + a)) / (2 * M_PI);
        float r,g,b;
        hsv_to_rgb(h, r, g, b);
        _z[i].colorR = r / 255.0;
        _z[i].colorG = g / 255.0;
        _z[i].colorB = b / 255.0;
    }

    for (int i = 0; i < n; i++)
    {
        float r_r = _z[i].r;
        float r_i = _z[i].i;

        float v_r = poly_r[0];
        float v_i = poly_i[0];
        for (int j = 1; j <= n; j++)
        {
            float v_r_tmp = v_r * r_r - v_i * r_i + poly_r[j];
            float v_i_tmp = v_r * r_i + v_i * r_r + poly_i[j];
            v_r = v_r_tmp;
            v_i = v_i_tmp;
        }

        float v_m = mag(v_i, v_r);
        if (v_m > ErrorMargin)
        {
            _z[i].r = ErrorMarker;
            _z[i].i = ErrorMarker;
            _z[i].colorR = 0;
            _z[i].colorG = 0;
            _z[i].colorB = 0;
        }
    }
}


void main()
{
    uint idx = gl_GlobalInvocationID.x;

    float poly_r[32];
    float poly_i[32];
    CompactComplexFloatWithColor _z[32];
    uint poly_len = config.order + 1; 

    uint rootsCount = config.polysCount * config.order; 
    if (idx >=0 && idx < config.polysCount) {


        // create poly from number
        uint polyIdx = idx;
        for (int j = 0; j < poly_len; j++)
        {
            uint coeffIdx = polyIdx % config.coeffValuesCount;
            polyIdx = polyIdx / config.coeffValuesCount;
            poly_r[j] = config.coeffsValues_r[coeffIdx];
            poly_r[j] = config.coeffsValues_i[coeffIdx];
        }

        evaluate_poly(poly_r, poly_i, config.order+1, _z);

        polyIdx = idx;
        for(int i=0; i<config.order; i++)
        {
            uint pointIdx = polyIdx * config.order + i; 
            points[pointIdx].r = _z[i].r; //idx*0.0001*cos(float(idx) * 0.1);
            points[pointIdx].i = _z[i].i; //idx*0.0001*sin(float(idx) * 0.1);
            points[pointIdx].colorR = _z[i].colorR;
            points[pointIdx].colorG = _z[i].colorG;
            points[pointIdx].colorB = _z[i].colorB;
        }

    } else if (idx < config.polysCount + config.coeffValuesCount) {
        uint coeffIdx = idx - config.polysCount;
        points[rootsCount + coeffIdx].r = config.coeffsValues_r[coeffIdx];
        points[rootsCount + coeffIdx].i = config.coeffsValues_i[coeffIdx];
        points[rootsCount + coeffIdx].colorR = 255.0;
        points[rootsCount + coeffIdx].colorG = 255.0;
        points[rootsCount + coeffIdx].colorB = 255.0;  
    }
}